//			第28組 
//資訊四甲 10527120 林育戎
//財金四乙 10447236 連盈媛 
#include <iostream>
#include <iomanip>
#include <fstream>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <vector>
#include <ctime>
#include <time.h>
#include <cstdlib>
#include <iterator>  
#include <algorithm>
#include <math.h>
#include <sstream>

using namespace std ;
static double unexist, exist ;

struct JobType {  
	    char id1[10] ; 
        char id2[10] ; 
        float weight ;
};

struct AType {  // 任務一所需 
	    string id ; 
        float weight ;
};

struct AList {
	string id ;
	vector<AType> aroundList ;
	bool hasPassed ;
};

class AdjacentLists {
	private:
		vector<JobType> JList ;  //讀入檔案用 
		
	public :
		vector<AList> adjList ; 
		
		bool Readfild (	string nof ) {
			char tempid1[10], tempid2[10] ;
			float flo ;	
			JobType tempJT ;
			fstream inputfile ; // 暫存檔 
			string inputfile_name = "pairs" + nof + ".bin" ; // 將"input"與檔名連接	
			const char* name = inputfile_name.c_str() ;
			
		//-------------------------------------------------------------------------- //讀檔		
			if ( FILE * file = fopen(name, "rb" ) ) {	 // 判斷檔案是否存在 
				for ( int i = 0 ; !feof(file) ; i++ ) {

					fread( tempid1 ,10 ,1, file) ; 
					fread( tempid2 ,10 ,1, file) ; 
					fread( &flo,sizeof(flo),1,file) ;
					
					

					strcpy ( tempJT.id1 , tempid1 ) ;   // 將資料寫入JList 
					strcpy ( tempJT.id2 , tempid2 ) ; 
					tempJT.weight = flo ; 
					JList.push_back(tempJT);
					
					//cout << "[" << i << "]" << "  " << JList.at(i).id1 << "  " << JList.at(i).id2 << "  " << JList.at(i).weight << endl ;		
					
				} // for
                fclose( file ) ;  // 檔案內容讀取完後關閉 
			} // if 
			else{
				cout << endl << name << " does not exist!!!" << endl << endl ;
				return  false ; 
			} // else
	    } // Readfild()
	    
		void sort( vector<AType> & list, int sel ) {     //希爾排序法	
			int gap = list.size()/2 ;
			for ( ; gap > 0 ; gap = gap / 2 ) {
				for ( int i = gap ; i < list.size() ; i ++ ) {
					if ( sel == 1 )	for ( int q = i ; q >= gap && list.at(q).id < list.at(q-gap).id ; q-=gap )	swap( list[q], list[q-gap] ) ;
					else	for ( int q = i ; q >= gap && list.at(q).weight > list.at(q-gap).weight ; q-=gap )	swap( list[q], list[q-gap] ) ;
				} // for
			} // for
			
		} // sort()
		
		void insert( char id1[10], char id2[10], float weight ) {
			int j = 0 ;
			bool found = false ;
			AList newList ;
	    	AType newNode ;
			for ( ; j < adjList.size() && !found ; j ++ )	if ( strcmp( adjList.at(j).id.c_str(), id1 ) == 0 )	found = true ;
			if ( found ) {
	    		j -- ;
    			newNode.id.assign(id2) ;
				newNode.weight = weight ;
				adjList.at(j).aroundList.push_back(newNode) ;
			} // if
			else {
				newList.id.assign(id1) ;
				newNode.id.assign(id2) ;
				newNode.weight = weight ;
				newList.aroundList.push_back(newNode) ;
				newList.hasPassed = false ;
				adjList.push_back(newList) ;
			} // else
			
		} // insert() 
	    
	    void build() {
	    	
	    	for ( int i = 0 ; i < JList.size()-1 ; i ++ ) { 
	    		insert( JList.at(i).id1, JList.at(i).id2, JList.at(i).weight ) ;
	    		//insert( JList.at(i).id2, JList.at(i).id1, JList.at(i).weight ) ;
			} // for
			
			//-----------------------------------------------------------------------------//  做排序
			for ( int gap = adjList.size()/2 ; gap > 0 ; gap = gap / 2 ) {
				for ( int i = gap ; i < adjList.size() ; i ++ ) {
					for ( int q = i ; q >= gap && adjList.at(q).id < adjList.at(q-gap).id ; q-=gap )	swap( adjList[q], adjList[q-gap] ) ;
				} // for
			} // for
			for ( int i = 0 ; i < adjList.size() ; i ++ )	sort( adjList.at(i).aroundList, 2 ) ;
	    	
		} // bulid()
		
		void outputFile( string nof ) {
			FILE *fanswer = NULL;
			string inputfile_name = "pairs" + nof + ".adj" ; // 將"input"與檔名連接	
			const char* name = inputfile_name.c_str() ;
			fanswer = fopen( name, "w") ;
			
			int sumNode = 0 ;
			fprintf( fanswer, "<<< There are %d IDs in total. >>>", adjList.size() ) ;
			for ( int i = 0 ; i < adjList.size() ; i ++ ) {
				fprintf ( fanswer, " \n[%3d] " , i+1  ) ;
				fprintf ( fanswer, "%s: \n" , adjList.at(i).id.c_str()  ) ;
				for ( int j = 0 ; j < adjList.at(i).aroundList.size() ; j ++ ) {
					fprintf ( fanswer, "\t(%2d) %s,  %4g "  , j+1 ,adjList.at(i).aroundList.at(j).id.c_str(), adjList.at(i).aroundList.at(j).weight ) ;
					if ( (j+1)%10 == 0 )	fprintf( fanswer, "\n") ;
				} // for
				sumNode = sumNode + adjList.at(i).aroundList.size() ;
			} // for	
			fprintf( fanswer, "\n<<< There are %d nodes in total. >>>", sumNode ) ;
			cout << endl << "<<< " << JList.size()-1 << " pairs => " << sumNode << " nodes >>>" << endl << endl ;
			cout << "Adjacency lists are written into a file..." << endl << endl ;
			cout << "<<< There are " << sumNode << " nodes in total. >>>" << endl << endl ;
			
			fclose( fanswer ) ;
		} // outputFile
		
};

struct ComponentNode {
	vector<AType> group ;
	ComponentNode *next ; 
};

class Traverse {
	private:
		ComponentNode *root ;
		ComponentNode *nowPtr ;
		
	public:
		ComponentNode *newPtr ;
		
		void initTraverse() {  //  初始化 
	        root = NULL ;
	        nowPtr = NULL ;
        } // initTraverse
        
        bool insert( AdjacentLists & aList, int num ) {
        	if ( !aList.adjList.at(num).hasPassed ) {
        		AType newNode ;
        		newNode.id = aList.adjList.at(num).id ;
        		newPtr->group.push_back(newNode) ;
        		aList.adjList.at(num).hasPassed = true ;
        		return true ;
			} // if
			return false ;
		} // insert()
        
        void traverse( AdjacentLists & aList, int num, int n ) {  // num:第幾個id，n:id的第幾個aroundList 	
        	if ( n < aList.adjList.at(num).aroundList.size() ) {
        		for ( int i = 0 ; i < aList.adjList.size() ; i ++ ) {   //找對應的id 
        			if (  aList.adjList.at(i).id == aList.adjList.at(num).aroundList.at(n).id ) {
        				if ( insert( aList, i ) ) {
        					traverse( aList, i, 0 ) ;
        					traverse( aList, num, n+1 ) ;
						} // if
						else	traverse( aList, num, n+1 ) ;
						i = aList.adjList.size() ;  // 使迴圈結束
					} // if 
				} // for
			} // if
			
		} // traverse
		
		int IsNotEnd( AdjacentLists & aList ) {
			int i ;
			for ( i = 0 ; i < aList.adjList.size() && aList.adjList.at(i).hasPassed ; i ++ ) ;
			if ( i < aList.adjList.size() )	return i ;
			else	return -1 ;
		} // IsNotEnd()
		
		void build( AdjacentLists & aList ) {
			int num = IsNotEnd( aList ) ;
			int time ;
			while( num != -1 ) {
				newPtr = new ComponentNode ;
				newPtr->next = NULL ;
				insert( aList, num ) ;
				traverse( aList, num, 0 ) ;
				//aList.sort( newPtr->group, 1 ) ;
				
				if ( root == NULL )	root = newPtr ;
				else {
					nowPtr = root ;
					ComponentNode *temp = nowPtr ;
					int i = 0 ;
					for ( i = 0 ; nowPtr != NULL && nowPtr->group.size() > newPtr->group.size() ; i ++ ) {
						if ( i != 0 )	temp = temp->next ;
						nowPtr = nowPtr->next ;
					} // while
					if ( nowPtr != NULL && i != 0 ) {
						temp->next = newPtr ;
						newPtr->next = nowPtr ;
					} // if
					else if ( i == 0 ) {
						root = newPtr ;
						newPtr->next = nowPtr ;
					} // else if 
					else	nowPtr->next = newPtr ;
				} // else

				num = IsNotEnd( aList ) ;
			} // while
			
		} // build
		
		void outputFile( string nof ) {
			FILE *fanswer = NULL;
			string inputfile_name = "pairs" + nof + ".cc" ; // 將"input"與檔名連接	
			const char* name = inputfile_name.c_str() ;	    	
			fanswer = fopen( name, "w") ;
			
			nowPtr = root ;
			for ( int i = 1 ; nowPtr != NULL ; i ++ ) {
				if ( i != 1 )	fprintf( fanswer, "\n") ;
				fprintf ( fanswer, "{%2d}  Connected Component: size = %d \n" , i, nowPtr->group.size() ) ;
				cout << endl << "{" << setw(2) << i << "} Connected Component: size = " << nowPtr->group.size() << endl ;
				for ( int j = 0 ; j < nowPtr->group.size() ; j ++ ) {
					fprintf ( fanswer, "\t(%3d) %s"  , j+1, nowPtr->group.at(j).id.c_str() ) ;
					cout << "\t(" << setw(3) << j+1 << ") " << nowPtr->group.at(j).id ;
					if ( (j+1)%5 == 0 )	{
						fprintf( fanswer, "\n") ;
						cout << endl ;
					} // if
				} // for
				nowPtr = nowPtr->next ;
			} // for
			fclose( fanswer ) ;
		} // outputFile
		
};


int main() { 
	string nof = "1" ;
	int ran = 1 ;
	while( nof != "0" && ran != 0 ) {
		AdjacentLists aList ;
		Traverse DEF ;
		DEF.initTraverse() ;
		cin >> nof ;
		if ( nof == "0" )  ran = 0 ;
		else if ( aList.Readfild( nof ) ) {
			aList.build() ;
			aList.outputFile( nof ) ;
			cout << "@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@" << endl ;
			cout << "Mission 2: Find connected components" << endl ;
			cout << "@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@" << endl << endl ;
			cout << "~~~ Connected Components ~~~" ;
			DEF.build( aList ) ;
			DEF.outputFile( nof ) ;
			cout << endl << endl << "[0]Quit or [Any other]continue?" << endl ;
			cin >> nof ;			
		} // else if	 
	} // while		
	
} // main() 



