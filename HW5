#include <sstream>
#include <stdio.h>
#include <iostream>
#include <string>
#include <vector>
#include <fstream>
#include <string.h>
# include <time.h> 
#include <math.h>
#include <iomanip>
#include <queue> 
#include <cstdlib>
using namespace std ;


struct data {
	char sid1[10]; 
	char sid2[10]; 
	float weight ; 
} ;

struct Link {
	char sid[10]; 	  
	float weight ; 
};

struct Node {
	char sid[10];  	  
	float weight ; 
	Node * next ;
} ;
struct DNode {
	Node * Id ; 
	int degree = 0 ;
	DNode * next ;
} ;

struct LinkArray {
	char sid[10];  	  
	float weight ;
	int degree ; 
	Link * next ;
} ;

struct NodeLink {
	char sid[10]; 	
	float weight; 
	vector<Link> connect ;			
	int degree = 0;
	NodeLink * next ;
}  ;

struct nodetype {
	char sid1[10] ;
	float weight ;
	bool find = false ;
};
struct anstype {
	char sid1[10] ; 
	int num ;
	vector<nodetype> match ; // 其他資料&配對權重 
	bool use ;
};
struct TwoType {
	char sid1[10] ;  
	float weight = 0;
	bool find = false ;
	int num ;
};
struct treetype {
	char sid1[10] ; 
	float minweight = 0;
	vector<nodetype> match ; // 其他資料&配對權重 
	bool find = false ;	
};

class Start{	
	public :
	vector<data> list ;
	vector<LinkArray> graph ;		
	vector<anstype> match ; // 配對的表 
	vector<nodetype> List ;
	vector<anstype> ConnectList ; //存放有關連的資料 
	vector<nodetype> TreeList ;
	vector<treetype> MemberList ;
	vector<TwoType> SecList ; // 存與指定學號有關 
	vector<treetype> MemberList2 ; // 跑每筆學號最短路徑 
	vector<TwoType> AnsList ; // 放最後答案 

	DNode *Data = NULL ;
	NodeLink * head	;
	NodeLink * root ;
	
		
	void init()  { // 初始化 
		list.clear() ;
		graph.clear() ;			
		match.clear() ; 
		List.clear() ;
		ConnectList.clear() ; 
		TreeList.clear() ;
		MemberList.clear() ; 
		SecList.clear() ; 
		MemberList2.clear() ; 
		AnsList.clear() ;		
	} // init()	
	
	void TextInput(string filename,string filenumber,float realnum) { //讀入檔案 
		ifstream inFile;
		filename = "pairs" + filenumber + ".bin";
		data temp ;
		inFile.open( filename.c_str(), ios::in | ios::binary ) ;
		if (!inFile){	
			cout << filename << " does not exist!!!\n\n";
		} //
		else {
			head = new NodeLink() ;
			for( int num = 0 ; inFile.read((char*)&temp, sizeof(data)) ; num++ ) { 
				if ( temp.weight <= realnum )
					list.push_back(temp) ;
			}
		} // else 
		
	} // Text2Binary	

	bool check( data temp, vector<LinkArray> &graph ) { // 檢查裡面是否有相同的 
		LinkArray temp1 ;
		if( graph.size() == 0 ){ // 空的 
			strcpy( temp1.sid, temp.sid1 ) ;  
			graph.push_back(temp1) ; // 丟進去 
		}
		for( int i = 0 ; i < graph.size() ; i++ ){
			if( strcmp( temp.sid1, graph.at(i).sid ) == 0 ){ // 是否有相同的 
				return 0 ;
			}
		}
		return 1 ;
	}
	
	void mission0( string filenumber,float realnum ) {	// 任務0 
		LinkArray temp ;
		data temp1 ;
		for( int i = 0 ; i < list.size() ; i++ ){		// 遍歷所有的點 
			strcpy( temp1.sid1, list.at(i).sid1) ;		// 找到就貼上 
			if( check( temp1 , graph ) ){
				strcpy( temp.sid, list.at(i).sid1 ) ;	
				temp.weight =list.at(i).weight ; 		
				graph.push_back(temp) ;
			}				
			strcpy( temp1.sid1, list.at(i).sid2) ;		
			if( check( temp1 , graph ) ){ // 檢查List內是否有重複的 
				strcpy( temp.sid, list.at(i).sid2 ) ;			
				temp.weight =list.at(i).weight ;
				graph.push_back(temp) ;
			}	
		}
		
		sort( graph ) ;													// 排序 				
		NodeLink * temp2 = new NodeLink() ;								// 存入指標 
		temp2 = head ;
		strcpy( temp2->sid, graph[0].sid ) ;	
		temp2->weight = graph[0].weight ;		
		temp2 -> degree = 1 ;
		
		for( int i = 1 ; i < graph.size() ; i++ ){
			temp2 -> next = new NodeLink() ;
			temp2 = temp2 -> next ;
			strcpy( temp2->sid, graph[i].sid ) ;
			temp2->weight = graph[i].weight ;
			temp2 -> degree = 0 ;
		}
				
		for( int i = 0 ; i < list.size() ; i++ ){								// 有先關的點連接起來 
			Link test ;
			for( NodeLink * temp = head ; temp != NULL ; temp = temp -> next ){
				if( strcmp( temp->sid, list[i].sid1 ) == 0 ){
					strcpy( test.sid, list[i].sid2 );
					test.weight = list[i].weight ;
					temp->connect.push_back( test ) ;
					temp->degree ++ ;
					break ;
				}
			}
			for( NodeLink * temp = head ; temp != NULL ; temp = temp -> next ){
				if( strcmp( temp->sid, list[i].sid2 ) == 0 ){
					strcpy( test.sid, list[i].sid1 );
					test.weight = list[i].weight ;
					temp->connect.push_back( test ) ;
					temp->degree ++ ;
					break ;
				}
			}
		}
		
		int ids = 0 ;
		
		for( NodeLink * temp = head ; temp != NULL ; temp = temp -> next ) {	
			ids++;
			sortinglist( temp ) ;																// 鏈結的排序
		} // for 
		
	    string rnum ; 			//型別轉換 
	    stringstream ss;
	    ss << realnum ;
	    ss >> rnum ;
		string filename = "Pairs" + filenumber + "_"+  rnum+ ".adj" ;										// 寫檔 
		ofstream outFile ;
		outFile.open(filename.c_str(), ios::out ) ;
		
		outFile << endl << "<<< There are " << ids << " ids in total. >>>" << endl ;		
		int nodes = 0,i = 0 ;
		
		for( NodeLink * temp3 = head ; temp3 != NULL ; temp3 = temp3 -> next  ){
			
			anstype test ;
			strcpy ( test.sid1,temp3->sid ) ;
			match.push_back(test) ;
			
			outFile << "[" << i+1 << "] " << temp3->sid << " :" << endl << "\t" ;                      //Output
			for( int j = 0 ; j < temp3->connect.size() ; j++ ){
				nodetype tempdata ;
				strcpy (tempdata.sid1 ,temp3->connect[j].sid) ;
				tempdata.weight = temp3->connect[j].weight ;
				match[i].match.push_back(tempdata) ;
				outFile  << "(" << j+1 << ") " << temp3->connect[j].sid << ",\t" << temp3->connect[j].weight << "\t" ;
				nodes++ ;
				if( (j+1)%10 == 0 )
					outFile << endl << "\t" ;
			}
			outFile << endl ;
			i++ ;
		}
		outFile << endl << "<<< There are " << nodes << " nodes in total. >>>" ;
		outFile.close() ;
		
		
		cout << "\n<<< There are " << ids << " ids in total. >>>" <<endl;								 			
		cout << "\n<<< There are " << nodes << " nodes in total. >>>"<< endl; 		
		
	} // mission0
	
	void sort( vector<LinkArray> &graph ) {
		data temp1 ;
		for(int i = 0; i < graph.size(); i++)   {                            // 排序 weight = 1  
	    	graph.at(i).degree = 1 ;
	        for(int j = 1; j < graph.size()- i; j++) {
	            if( strcmp( graph.at(j).sid, graph.at(j-1).sid ) <= 0 )  {
	                strcpy( temp1.sid1, graph.at(j-1).sid ) ;
	                strcpy( graph.at(j-1).sid, graph.at(j).sid ) ;
	                strcpy( graph.at(j).sid, temp1.sid1 ) ;
	                
	                temp1.weight= graph.at(j-1).weight ;
	                graph.at(j-1).weight = graph.at(j).weight ;
	                graph.at(j).weight= temp1.weight ;	                
	                
	            }
	        }
	    }
	    
	}
	void sortinglist( NodeLink *temp ){													// 排序 
		Link temp1 ;
		for( int i = 0 ; i < temp->connect.size() ; i++ ){
	        for(int j = 1; j < temp->connect.size()- i; j++) {
	            if( temp->connect[j].weight < temp->connect[j-1].weight  )  {
	                strcpy( temp1.sid, temp->connect[j-1].sid ) ;
	                strcpy( temp->connect[j-1].sid, temp->connect[j].sid ) ;
	                strcpy( temp->connect[j].sid, temp1.sid ) ;
	                temp1.weight = temp->connect[j-1].weight ;
	                temp->connect[j-1].weight = temp->connect[j].weight ;
	                temp->connect[j].weight = temp1.weight ;
	            }
	        }
	    	
		}
	}

	void mission1( string filenumber,float realnum ) {	
		Data = NULL ;
		DNode *Data2 = NULL ;
		DNode *Data3 = NULL ;	
		for( NodeLink * temp = head ;  temp != NULL ; temp = temp -> next ) {
			if( !found( temp->sid ,Data ) ) {
				if ( Data == NULL )			
					Dfs( temp->sid ,temp->weight, head, temp, Data ) ;
				else {
					Dfs( temp->sid,temp->weight, head, temp, Data2 ) ;
					for( Data3 = Data ; Data3->next != NULL ; Data3 = Data3 -> next ) ;
					Data3->next = Data2 ;
					Data2 = NULL ;
					Data3 = NULL ;
				}
			}
		}	
		Output_Mission1( Data, filenumber,realnum ) ;
	}	
	
	void Dfs( char sid[10] ,float weight , NodeLink * head, NodeLink * temp, DNode *&Data ){	
		if ( Data == NULL ) {
			DNode * temp2 = new DNode ;
			Node * temp3 = new Node ;
			strcpy( temp3->sid, sid ) ;
			temp3 -> weight = weight ;
			temp3->next = NULL ;
			temp2->Id = temp3 ; 
			temp2->next = NULL ;
			Data = temp2 ;	
			Data->degree++ ;	
		}
		else {
			DNode * temp2 = Data ;
			Node * temp3 = temp2->Id ;  
			Node * temp4 ;
			for( temp4 = temp3 ; temp4->next != NULL ; temp4 = temp4->next ) ;
			temp4->next = new Node ;
			temp4 = temp4->next ;
			strcpy( temp4->sid, sid ) ;
			temp4 -> weight = weight ;
			temp4->next = NULL ;
			Data->degree++ ;
		}
	
		NodeLink * find = NULL ;
		for( int i = 0 ; i < temp->connect.size() ; i++ ) {
			if ( !found2( temp->connect[i].sid, Data) ) {
				for ( find = head ; find != NULL ; find = find->next ) {
					if ( strcmp( temp->connect[i].sid, find->sid ) == 0 ) break ;
				}
				Dfs( temp->connect[i].sid,temp->connect[i].weight, head, find, Data ) ;
			}
		}
	
	}
	
	bool found( char id[10] , DNode *Data  ) {
		DNode * temp = Data ;
		if ( temp == NULL ) 
			return false ;
		else {
			for ( ; temp != NULL ; temp = temp->next ) {
				for( Node * temp2 = temp->Id ; temp2 != NULL ; temp2 = temp2->next ) {
					if ( strcmp( id, temp2->sid ) == 0 ) 
						return true ;
				} 
			}	
		}
		return false ;
	}
	
	bool found2( char id[10], DNode*Data ) {
		if ( Data == NULL ) 
			return false ;	
		else {
			Node* temp = Data->Id ;
			for ( ; temp != NULL ; temp = temp -> next ) {
				if ( strcmp( id, temp->sid ) == 0 ) return true ;
			}
		}	
	
		return false ;
	}	
		
	void Ssortinglist( NodeLink *temp ){													// 排序 
		Link temp1 ;
		for( int i = temp->connect.size()-1 ; i >0 ; i-- ){
	        for(int j = 0 ; j <= i-1; j++) {
 				string x = temp->connect[j].sid ; 
 				string y = temp->connect[j+1].sid ; 
 				if ( x > y ) {				 
	                strcpy( temp1.sid, temp->connect[j+1].sid ) ;
	                strcpy( temp->connect[j+1].sid, temp->connect[j].sid ) ;
	                strcpy( temp->connect[j].sid, temp1.sid ) ;
	            }
	        }
	    	
		}
	}
	
	void Swap( DNode * Data, DNode * Data2 )	{
		int tempdegree = Data -> degree ; 
		Node * temp = Data -> Id ;		
		Data -> Id = Data2 -> Id;
		Data -> degree = Data2 -> degree ;
		Data2 -> Id = temp ;			
		Data2 -> degree = tempdegree ;			
	} // swap
		
	void ListToNode() {  // 將list轉成指標  
		root = new NodeLink() ;
		NodeLink * cur = root ;
		
		for( DNode *temp = Data ; temp != NULL ; temp = temp -> next ) {
			cur -> degree = temp -> degree ;
			for( Node *temp2 = temp->Id ; temp2 != NULL ; temp2 = temp2 -> next ) {
				Link tempsid ;
				strcpy ( tempsid.sid, temp2->sid ) ;
				tempsid.weight = temp2->weight ;
				cur ->connect.push_back(tempsid) ;
			} // for 
			cur->next = new NodeLink() ;
			cur = cur->next ;
		} // for 
	
			
	} // ListToNode

	void ListToNode2() { // 將list轉成指標 
		ConnectList.clear() ;
		anstype cur ;
		int i = 0 ; 
		for( DNode *temp = Data ; temp != NULL ; temp = temp -> next ) {			
			cur.num  = temp -> degree ;
			ConnectList.push_back(cur) ;			
			for( Node *temp2 = temp->Id ; temp2 != NULL ; temp2 = temp2 -> next ) {
				nodetype tempsid; 
				strcpy ( tempsid.sid1, temp2->sid ) ;
				tempsid.weight = temp2->weight ;
				ConnectList[i].match.push_back(tempsid) ;
			} // for 
			i++ ;
		} // for 
			
	} // ListToNode	
	
	
	void Output_Mission1( DNode *Data, string filenumber, float realnum ) {
		int i = 1;
	    string rnum ;
	    stringstream ss;
	    ss << realnum ;
	    ss >> rnum ;		
		
		string filename = "Pairs" + filenumber + "_"+ rnum+ ".cc" ;
		ofstream outFile ;
		outFile.open( filename.c_str(), ios::out ) ;

		int connum = 0 ;
		for( DNode *d1 = Data ; d1 != NULL ; d1 = d1 -> next ) {
			connum++ ;
			for( DNode *d2 = Data ; d2->next != NULL ; d2 = d2 -> next ) {	
				if ( d1 -> degree > d2 -> degree) 
					Swap(d1,d2) ;
			} // for 

		} // for 
		ListToNode() ;
		ListToNode2() ;
		for( NodeLink * temp = root; temp != NULL ; temp = temp -> next ) {	
			Ssortinglist( temp ) ;																// 鏈結的排序
		} // for 		
		
		cout <<"\n<<< There are "<<connum << " connected components in total. >>>" << endl ; 
		outFile <<"\n<<< There are "<<connum << " connected components in total. >>>" << endl ; 							
		for( NodeLink * temp = root ; temp != NULL ; temp = temp -> next  ){
			if ( temp->connect.size() > 0 ) {
				cout << "(" << i << ") Connected Component: size = " << temp->degree<< endl ; 
				outFile << "(" << i << ") Connected Component: size = " << temp->degree ; 		
				for( int j = 0 ; j < temp->connect.size() ; j++ ){
					if ( j % 5 == 0 ) {
						outFile << "\n     " ;
					}

					outFile << "(" << j+1 << ") " <<  temp->connect[j].sid << "  " ; 
				}
				outFile << endl ;
				i++ ;
			}	
		}		
		outFile.close() ;
	}	
